## 배열의 생성

#### 1. 배열 리터럴

```js
const arr = [1, 2, 3];
```

</br>

#### 2. Array 생성자 함수

- 전달된 인수가 1개에 그 인수가 __'숫자'__ 인 경우 - 인수인 숫자를 length 프로퍼티의 값으로 갖는 배열을 생성한다.

```js
const arr = new Array(10);

console.log(arr); // [empty × 10] length 가 10 이지만 실제 요소는 없는 희소배열이다.
console.log(arr.length); // 10
```

- 전달된 인수가 __'없는'__ 경우 -  빈 배열을 생성한다. 즉, 배열 리터럴 [ ]과 같다.

```js
const empty = new Array();

console.log(empty); // []
```

- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우 - __인수를 요소로 갖는 배열을 생성한다.__

```js
// 전달된 인수가 1개이지만 숫자가 아닌 원시값이거나 객체면 인수를 요소로 갖는 배열을 생성한다.
const arr1 = new Array({});

console.log(arr1); // [{}] 

// 전달된 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.
const arr2 = new Array(1, 2, 3);

console.log(arr2); // [1, 2, 3]
```

</br>

Array 생성자 함수는 new 연산자와 함께 호출하지 않더라도, 배열을 생성하는 생성자 함수로 동작한다.

아래의 Array.of 와 Array.from은 new 연산자를 사용하지 않는 Array 생성자 함수 '생성'방법이다.

</br>

#### 3. Array.of

전달받은 인수를 배열의 요소로 갖는다.

Array.of의 장점은 생성자 함수와 다르게 인수에 숫자로 써도 인수를 요소로 갖는다. ( Array 생성자 함수 보완 가능 )

```js
const arr2 = Array.of(1, 2, 3);
console.log(arr2); // [1, 2, 3]
```

</br>

#### 4. Array.from

전달받은 인수인 __'유사배열 객체'__ 혹은 __'이터러블 객체'__ 를 배열로 변환해준다. 

- 유사배열 객체로는 arguments와 문자열이 있다. ( arguments도 배열로 변환해주긴 하는데 생긴게 복잡하다. )

- 이터러블 객체(iterable object)는 Symbol.iterator 메소드를 구현하여 for…of 문으로 '순회'할 수 있으며 스프레드 문법의 대상으로 사용할 수 있는 객체를 말한다

Array.from의 인수는 첫번째 인수와 두번째 인수가 하는 역할이 다르다. 첫번째 인수에 유사배열 혹은 이터러블 객체를 넣었으면, 두번째 인수에는 함수를 넣어서 첫번째 인수로 만든 __배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.__

```js
// 문자열은 이터러블이다.
const arr1 = Array.from('Hello');
console.log(arr1); // ['H', 'e', 'l', 'l', 'o']

// 유사 배열 객체를 새로운 배열을 변환하여 반환한다.
const arr2 = Array.from({ length: 2, 0: 'a', 1: 'b' });
console.log(arr2); // ['a', 'b']
```

</br>

## 배열 요소의 참조

배열 요소를 참조할 때는 대괄호 표기법 arr[ ]을 사용한다. 대괄호 안에는 인덱스가 온다.

참고로 객체 프로퍼티 참조는 . 과 [ ] 두가지 방법을 사용한다.

사실 배열은 객체다. 배열의 [ ]도 배열이란 객체의 프로퍼티 참조법이다. 

> 인덱스 = 프로퍼티 키   /   요소 = 프로퍼티 값

```js
// 배열 arr1과 객체 arr2의 내부는 아래처럼 같은 구조이다.

const arr1 = ['a', 'b']
const arr2 = { 
		0 : 'a',
    1 : 'b',
}
  
console.log(arr1[0],arr1[1]); // a   b
console.log(arr2[0],arr2[1]); // a   b 
```

프로퍼티 키는 식별자 네이밍 규칙을 따라야 하고 식별자 네이밍 규칙에 따르지 않는다면 [' '] 이렇게 문자열로 묶어서 대괄호 표기법으로 작성해야 한다. 식별자 네이밍 규칙 따르지 않으면 . 마침표 표기법은 못쓴다.

이때 프로퍼티 키 위치에서는 __숫자만 예외적으로__ [ 0 ]을 [ '0' ]과 같이 암묵적으로 __문자열로 전환__ 해준다. 

0 : 'a', 도 내부적으로는 '0' : 'a', 로 인식한다. 따라서 배열의 요소를 참조할 때 [ 0 ] 와 같이 인덱스를 쓰면 되는 것이다.

같은 이유로 존재하지 않는 프로퍼티 키로 객체의 프로퍼티에 접근했을 때 undefined를 반환하는 것처럼 배열도 존재하지 않는 요소를 참조하면 undefined가 반환한다. 희소배열의 빈 인덱스를 참조해도 undefined가 반환된다.

</br>

## 배열 요소의 추가와 갱신

객체 프로퍼티 동적 추가와 마찬가지로 배열에도 요소를 동적으로 추가할 수 있다. 이때 argument와는 다르게 __length 프로퍼티 값은 자동 갱신된다.__

배열의 요소 추가는 없는 인덱스에 요소 값을 할당하면 요소가 __동적 추가__ 된다.

```js
const arr = [];

arr[0] = 'a';

console.log(arr); // ['a']
```

배열의 요소 갱신은 있는 인덱스에 요소 값을 재할당하면 요소값이 __갱신__ 된다.

```js
const arr = ['a'];

arr[0] = 'b';

console.log(arr); // ['b']
```

</br>

##  배열 요소의 삭제





### sort 메서드

( ) 매개변수 안에는 함수가 들어온다. 그 함수안에 또 매개변수를 ( , ) 두개까지 넣을 수 있는데 이 두개가 비교된다.

